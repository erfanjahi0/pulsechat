<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PulseChat</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='8' fill='%236478ff'/><path d='M7 11h18M7 16h12M7 21h8' stroke='white' stroke-width='2.5' stroke-linecap='round'/></svg>" />
  <link rel="stylesheet" href="assets/css/base.css" />
  <link rel="stylesheet" href="assets/css/app.css" />
  <script>
    // Apply theme before paint to prevent flash
    (function() {
      const t = localStorage.getItem('pulsechat_theme');
      if (t) document.documentElement.setAttribute('data-theme', t);
      else if (!window.matchMedia('(prefers-color-scheme: dark)').matches)
        document.documentElement.setAttribute('data-theme', 'light');
    })();
  </script>
</head>
<body>
<div id="toast-container"></div>

<div class="app-shell" id="app-shell">

  <!-- ════════════════ SIDEBAR ════════════════ -->
  <aside class="sidebar" id="sidebar" aria-label="Conversations">
    <header class="sidebar-header">
      <div class="sidebar-logo" aria-label="PulseChat">
        <div class="sidebar-logo-mark" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
          </svg>
        </div>
        PulseChat
      </div>
      <div class="sidebar-actions">
        <button class="theme-toggle" id="theme-btn" title="Toggle theme">
          <svg class="icon-moon" width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
          <svg class="icon-sun"  width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
        </button>
        <a href="profile.html" class="btn btn-icon" aria-label="Profile settings">
          <svg width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="8" r="4"/><path d="M4 20c0-4 3.6-7 8-7s8 3 8 7"/></svg>
        </a>
        <button class="btn btn-icon" id="logout-btn" aria-label="Sign out">
          <svg width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9"/></svg>
        </button>
      </div>
    </header>

    <div class="sidebar-search">
      <div class="search-wrap" role="search">
        <div class="search-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
          </svg>
        </div>
        <input class="search-input" type="search" id="search-input"
               placeholder="Search @username or email…"
               autocomplete="off" spellcheck="false"
               aria-label="Search by username or email" />
      </div>
    </div>

    <div class="search-results" id="search-results" role="listbox" aria-label="Search results"></div>
    <p class="sidebar-section-label" id="chats-label">Messages</p>
    <div class="chat-list" id="chat-list" role="list" aria-label="Conversations"></div>
  </aside>

  <!-- ════════════════ CHAT AREA ════════════════ -->
  <main class="chat-area" id="chat-area" aria-label="Chat">

    <!-- Empty / no chat selected -->
    <div id="chat-empty-state" style="flex:1;display:flex;flex-direction:column;"></div>

    <!-- Active chat wrapper — uses a visibility trick instead of display:contents -->
    <div id="chat-header-wrap" class="hidden" style="display:flex;flex-direction:column;flex:1;overflow:hidden;">
      <header class="chat-header" id="chat-header">
        <button class="btn btn-icon back-btn" id="back-btn" aria-label="Back">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="m15 18-6-6 6-6"/></svg>
        </button>
        <div id="chat-header-avatar"></div>
        <div class="chat-header-info">
          <div class="chat-header-name"   id="chat-header-name">—</div>
          <div class="chat-header-handle" id="chat-header-handle"></div>
        </div>
        <button class="btn btn-icon" id="block-btn" title="Block user" aria-label="Block user">
          <svg width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
            <circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/>
          </svg>
        </button>
      </header>

      <div class="blocked-banner hidden" id="blocked-banner">
        <span id="blocked-banner-text">You have blocked this user.</span>
        <button class="btn btn-secondary" style="padding:5px 12px;font-size:0.8125rem;" id="unblock-inline-btn">Unblock</button>
      </div>

      <div class="messages-wrap" id="messages-wrap" role="log" aria-live="polite" aria-label="Messages"></div>

      <div class="typing-indicator" id="typing-indicator" aria-live="polite">
        <div class="typing-dots" aria-hidden="true"><span></span><span></span><span></span></div>
      </div>

      <div class="composer" id="composer-area">
        <textarea class="composer-input" id="composer-input"
                  placeholder="Message…" rows="1"
                  aria-label="Type your message"></textarea>
        <button class="composer-send" id="send-btn" disabled aria-label="Send message">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round">
            <path d="m22 2-11 11M22 2 15 22l-4-9-9-4 20-7z"/>
          </svg>
        </button>
      </div>
    </div>

  </main>
</div>

<script type="module">
import { auth } from './assets/js/firebase.js';
import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';
import { requireAuth } from './assets/js/guard.js';
import { logout, upsertUser } from './assets/js/auth.js';
import { getUser, searchUsers, touchLastSeen, blockUser, unblockUser, getBlockStatus } from './assets/js/users.js';
import { subscribeChatList, getOrCreateChat, clearUnread } from './assets/js/chats.js';
import { subscribeMessages, sendMessage, loadMoreMessages, setTyping } from './assets/js/messages.js';
import {
  toast, buildAvatar, renderChatListSkeletons, renderMessageSkeletons,
  setVisible, showEmptyChat, showModal
} from './assets/js/ui.js';
import { debounce, formatTime, formatDateLabel, isSameDay, safeText, isMobile } from './assets/js/utils.js';
import { loadTheme, wireThemeButton } from './assets/js/theme.js';

// ── Theme ──────────────────────────────────────────────────
loadTheme();
wireThemeButton(document.getElementById('theme-btn'));

// ── Auth guard ─────────────────────────────────────────────
const me = await requireAuth();

// FIX: Ensure Firestore profile exists — covers Google sign-in edge case
// where upsertUser may have been skipped during the redirect flow.
let myProfile = await getUser(me.uid);
if (!myProfile) {
  const provider = me.providerData?.[0]?.providerId === 'google.com' ? 'google' : 'password';
  myProfile = await upsertUser(me, { authProvider: provider });
  myProfile = await getUser(me.uid); // re-fetch after creation
}

if (!myProfile) {
  toast('Profile error — please sign out and sign in again.', 'error');
}

touchLastSeen(me.uid);

// ── State ──────────────────────────────────────────────────
let activeChatId    = null;
let activeOtherUid  = null;
let activeOtherUser = null;
let msgUnsubscribe  = null;
let chatListUnsub   = null;
let lastMsgDoc      = null;
let hasMoreMsgs     = true;
let isLoadingMore   = false;
let currentMessages = [];
let blockStatus     = { iBlocked: false, theyBlocked: false };

// ── DOM refs ───────────────────────────────────────────────
const chatList         = document.getElementById('chat-list');
const searchInput      = document.getElementById('search-input');
const searchResults    = document.getElementById('search-results');
const chatsLabel       = document.getElementById('chats-label');
const chatHeaderWrap   = document.getElementById('chat-header-wrap');
const chatEmptyState   = document.getElementById('chat-empty-state');
const messagesWrap     = document.getElementById('messages-wrap');
const composerInput    = document.getElementById('composer-input');
const sendBtn          = document.getElementById('send-btn');
const chatHeaderName   = document.getElementById('chat-header-name');
const chatHeaderHandle = document.getElementById('chat-header-handle');
const chatHeaderAvatar = document.getElementById('chat-header-avatar');
const blockedBanner    = document.getElementById('blocked-banner');
const blockedBannerTxt = document.getElementById('blocked-banner-text');
const unblockInlineBtn = document.getElementById('unblock-inline-btn');
const sidebar          = document.getElementById('sidebar');
const chatArea         = document.getElementById('chat-area');
const backBtn          = document.getElementById('back-btn');
const logoutBtn        = document.getElementById('logout-btn');
const blockBtn         = document.getElementById('block-btn');

showEmptyChat(chatEmptyState);

// ── Chat list subscription ─────────────────────────────────
renderChatListSkeletons(chatList, 4);

chatListUnsub = subscribeChatList(me.uid, async (chats, err) => {
  // FIX: Handle errors surfaced from the subscription
  if (err) {
    if (err === 'INDEX_MISSING') {
      chatList.innerHTML = `
        <div class="search-empty-state">
          <p style="color:var(--warn);">⚠️ Firestore index missing.</p>
          <p style="margin-top:6px;font-size:0.8rem;">Open the browser console to find the index creation link, or see README.</p>
        </div>`;
    } else {
      chatList.innerHTML = `<div class="search-empty-state"><p>Failed to load conversations.</p></div>`;
    }
    return;
  }

  if (!chats || chats.length === 0) {
    chatList.innerHTML = `
      <div class="search-empty-state">
        <p>No conversations yet.</p>
        <p style="margin-top:4px;font-size:0.8rem;">Search someone to start chatting.</p>
      </div>`;
    return;
  }

  // Fetch profiles for all chat partners
  const otherUids = [...new Set(chats.map(c => c.participants?.find(u => u !== me.uid)).filter(Boolean))];
  const userCache = {};
  await Promise.all(otherUids.map(async uid => { userCache[uid] = await getUser(uid); }));

  const frag = document.createDocumentFragment();
  for (const chat of chats) {
    const otherUid = chat.participants?.find(u => u !== me.uid);
    const other    = userCache[otherUid] || { displayName: 'Unknown', uid: otherUid };
    const unread   = chat.unreadCount?.[me.uid] || 0;

    const item = document.createElement('div');
    item.className = `chat-list-item${chat.id === activeChatId ? ' active' : ''}`;
    item.setAttribute('role', 'listitem');
    item.setAttribute('tabindex', '0');
    item.setAttribute('aria-label', `Chat with ${other.displayName}`);
    item.dataset.chatId   = chat.id;
    item.dataset.otherUid = otherUid;

    item.appendChild(buildAvatar(other, 'md'));
    item.insertAdjacentHTML('beforeend', `
      <div class="chat-item-info">
        <div class="chat-item-top">
          <span class="chat-item-name truncate">${safeText(other.displayName)}</span>
          <span class="chat-item-time">${formatTime(chat.lastMessageAt)}</span>
        </div>
        <div class="chat-item-bottom">
          <span class="chat-item-last">${safeText(chat.lastMessageText || 'New conversation')}</span>
          ${unread > 0 ? `<span class="badge">${unread > 99 ? '99+' : unread}</span>` : ''}
        </div>
      </div>
    `);

    const openFn = () => openChat(chat.id, otherUid, other);
    item.addEventListener('click', openFn);
    item.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openFn(); }});
    frag.appendChild(item);
  }

  chatList.innerHTML = '';
  chatList.appendChild(frag);
});

// ── Open chat ──────────────────────────────────────────────
async function openChat(chatId, otherUid, otherUserData) {
  // Avoid duplicate open, but still show on mobile
  if (activeChatId === chatId && !isMobile()) {
    updateActiveChatItem(chatId);
    return;
  }

  // Tear down previous subscription
  if (msgUnsubscribe) { msgUnsubscribe(); msgUnsubscribe = null; }

  activeChatId    = chatId;
  activeOtherUid  = otherUid;
  activeOtherUser = otherUserData;
  currentMessages = [];
  lastMsgDoc      = null;
  hasMoreMsgs     = true;

  // FIX: Use a proper container div (not display:contents) — swap visibility
  chatEmptyState.style.display = 'none';
  chatHeaderWrap.classList.remove('hidden');
  chatHeaderWrap.style.display = 'flex';

  // Update header
  const user = otherUserData || await getUser(otherUid);
  chatHeaderAvatar.innerHTML = '';
  chatHeaderAvatar.appendChild(buildAvatar(user || { displayName: 'Unknown' }, 'md'));
  chatHeaderName.textContent   = user?.displayName || 'Unknown';
  chatHeaderHandle.textContent = user?.username ? `@${user.username}` : '';

  updateActiveChatItem(chatId);

  // Check block status
  blockStatus = await getBlockStatus(me.uid, otherUid);
  updateBlockUI();

  // Clear unread
  clearUnread(chatId, me.uid).catch(() => {});

  // Show skeleton while loading
  renderMessageSkeletons(messagesWrap, 5);

  // Subscribe to messages
  const { unsubscribe, firstLoad } = subscribeMessages(chatId, (msgs, lastDoc) => {
    lastMsgDoc      = lastDoc;
    hasMoreMsgs     = msgs.length >= 30;
    currentMessages = msgs;
    renderMessages(msgs);
  });

  msgUnsubscribe = unsubscribe;

  // Wait for first batch of messages before scrolling
  await firstLoad;

  if (isMobile()) showChatArea();

  // Only focus if not blocked
  if (!blockStatus.iBlocked && !blockStatus.theyBlocked) {
    composerInput.focus();
  }
}

function updateActiveChatItem(chatId) {
  document.querySelectorAll('.chat-list-item').forEach(el => {
    el.classList.toggle('active', el.dataset.chatId === chatId);
  });
}

// ── Block UI ──────────────────────────────────────────────
function updateBlockUI() {
  const blocked  = blockStatus.iBlocked;
  const byThem   = blockStatus.theyBlocked;
  const anyBlock = blocked || byThem;

  setVisible(blockedBanner, anyBlock);
  if (blocked)     blockedBannerTxt.textContent = 'You have blocked this user. They cannot message you.';
  else if (byThem) blockedBannerTxt.textContent = 'You cannot message this person.';

  setVisible(unblockInlineBtn, blocked);
  composerInput.disabled = anyBlock;
  sendBtn.disabled       = anyBlock || composerInput.value.trim().length === 0;
  composerInput.placeholder = anyBlock ? 'Messaging not available.' : 'Message…';
  blockBtn.style.color = blocked ? 'var(--error)' : '';
  blockBtn.title = blocked ? 'Unblock user' : 'Block user';
}

blockBtn.addEventListener('click', () => {
  if (!activeOtherUid) return;
  const name = safeText(activeOtherUser?.displayName || 'this user');

  if (blockStatus.iBlocked) {
    showModal({
      title: 'Unblock user',
      body: `<p>Unblock <strong>${name}</strong>? They will be able to message you again.</p>`,
      actions: [
        { label: 'Cancel',  class: 'btn-secondary', onClick: c => c() },
        { label: 'Unblock', class: 'btn-primary',   onClick: async c => {
          c();
          try { await unblockUser(me.uid, activeOtherUid); blockStatus.iBlocked = false; updateBlockUI(); toast('User unblocked.', 'success'); }
          catch { toast('Failed to unblock.', 'error'); }
        }},
      ],
    });
  } else {
    showModal({
      title: 'Block user',
      body: `<p>Block <strong>${name}</strong>? They cannot send you messages. You can unblock anytime.</p>`,
      actions: [
        { label: 'Cancel', class: 'btn-secondary', onClick: c => c() },
        { label: 'Block',  class: 'btn-danger',    onClick: async c => {
          c();
          try { await blockUser(me.uid, activeOtherUid); blockStatus.iBlocked = true; updateBlockUI(); toast(`${name} blocked.`, 'info'); }
          catch { toast('Failed to block.', 'error'); }
        }},
      ],
    });
  }
});

unblockInlineBtn.addEventListener('click', async () => {
  if (!activeOtherUid) return;
  try { await unblockUser(me.uid, activeOtherUid); blockStatus.iBlocked = false; updateBlockUI(); toast('User unblocked.', 'success'); }
  catch { toast('Failed to unblock.', 'error'); }
});

// ── Render messages ────────────────────────────────────────
function renderMessages(msgs) {
  const ordered  = [...msgs].reverse();
  const atBottom = isNearBottom();
  const frag     = document.createDocumentFragment();
  messagesWrap.innerHTML = '';

  if (hasMoreMsgs && msgs.length >= 30) {
    const btn = document.createElement('button');
    btn.className   = 'load-more-btn';
    btn.textContent = 'Load earlier messages';
    btn.addEventListener('click', handleLoadMore);
    frag.appendChild(btn);
  }

  let prevDate = null;
  for (const msg of ordered) {
    const ts   = msg.createdAt?.toDate ? msg.createdAt.toDate() : new Date();
    const mine = msg.from === me.uid;

    if (!prevDate || !isSameDay(ts, prevDate)) {
      const div = document.createElement('div');
      div.className   = 'msg-day-divider';
      div.textContent = formatDateLabel(ts);
      frag.appendChild(div);
      prevDate = ts;
    }

    const row = document.createElement('div');
    row.className = `msg-row ${mine ? 'mine' : 'theirs'}`;
    row.dataset.msgId = msg.id;

    if (!mine) {
      const sp = document.createElement('div');
      sp.className = 'msg-avatar-space';
      row.appendChild(sp);
    }

    const wrap   = document.createElement('div');
    wrap.className = 'msg-bubble-wrap';

    const bubble = document.createElement('div');
    bubble.className   = 'msg-bubble';
    bubble.textContent = msg.text;
    wrap.appendChild(bubble);

    const timeEl = document.createElement('div');
    timeEl.className   = 'msg-time';
    timeEl.textContent = formatTime(msg.createdAt);
    timeEl.setAttribute('aria-hidden', 'true');
    wrap.appendChild(timeEl);

    row.appendChild(wrap);
    frag.appendChild(row);
  }

  messagesWrap.appendChild(frag);
  if (atBottom || ordered.length <= 30) scrollToBottom();
}

function isNearBottom() {
  const { scrollTop, scrollHeight, clientHeight } = messagesWrap;
  return scrollHeight - scrollTop - clientHeight < 120;
}
function scrollToBottom() { messagesWrap.scrollTop = messagesWrap.scrollHeight; }

// ── Load more messages ─────────────────────────────────────
async function handleLoadMore() {
  if (isLoadingMore || !lastMsgDoc) return;
  isLoadingMore = true;
  const btn = messagesWrap.querySelector('.load-more-btn');
  if (btn) { btn.textContent = 'Loading…'; btn.disabled = true; }
  try {
    const prevH = messagesWrap.scrollHeight;
    const { messages, newLastDoc } = await loadMoreMessages(activeChatId, lastMsgDoc);
    lastMsgDoc      = newLastDoc;
    hasMoreMsgs     = messages.length >= 30;
    currentMessages = [...currentMessages, ...messages];
    renderMessages(currentMessages);
    messagesWrap.scrollTop = messagesWrap.scrollHeight - prevH;
  } catch { toast('Failed to load older messages.', 'error'); }
  finally   { isLoadingMore = false; }
}

// ── Send message ───────────────────────────────────────────
async function handleSend() {
  const text = composerInput.value.trim();
  if (!text || !activeChatId) return;
  if (blockStatus.iBlocked || blockStatus.theyBlocked) return;

  composerInput.value = '';
  composerInput.style.height = '';
  sendBtn.disabled = true;

  try {
    await sendMessage(activeChatId, me.uid, activeOtherUid, text);
    setTyping(activeChatId, me.uid, false);
  } catch (err) {
    toast('Failed to send. Please try again.', 'error');
    composerInput.value = text;
    console.error('sendMessage error:', err);
  }
}

sendBtn.addEventListener('click', handleSend);

composerInput.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); }
});

composerInput.addEventListener('input', () => {
  const has = composerInput.value.trim().length > 0;
  sendBtn.disabled = !has || !activeChatId || blockStatus.iBlocked || blockStatus.theyBlocked;
  composerInput.style.height = 'auto';
  composerInput.style.height = Math.min(composerInput.scrollHeight, 120) + 'px';
  if (activeChatId) setTyping(activeChatId, me.uid, has).catch(() => {});
});

// ── Search ─────────────────────────────────────────────────
function showChatListSection() {
  searchResults.innerHTML = '';
  searchResults.classList.remove('visible');
  chatList.style.display   = '';
  chatsLabel.style.display = '';
}

const handleSearch = debounce(async (term) => {
  term = term.trim();
  if (!term) { showChatListSection(); return; }

  chatList.style.display    = 'none';
  chatsLabel.style.display  = 'none';
  searchResults.classList.add('visible');
  searchResults.innerHTML = `<div class="search-empty-state">Searching…</div>`;

  try {
    const users = await searchUsers(term, me.uid);

    if (!users.length) {
      searchResults.innerHTML = `
        <div class="search-empty-state">
          <p>No users found.</p>
          <p style="margin-top:4px;font-size:0.8rem;">Try their full @username or email address.</p>
        </div>`;
      return;
    }

    const frag = document.createDocumentFragment();
    for (const user of users) {
      const item = document.createElement('div');
      item.className = 'search-result-item';
      item.setAttribute('role', 'option');
      item.setAttribute('tabindex', '0');
      item.setAttribute('aria-label', `Start chat with ${user.displayName}`);
      item.appendChild(buildAvatar(user, 'md'));
      item.insertAdjacentHTML('beforeend', `
        <div class="search-result-info">
          <div class="search-result-name">${safeText(user.displayName)}</div>
          <div class="search-result-handle">${user.username ? '@' + safeText(user.username) : safeText(user.email || '')}</div>
        </div>
      `);

      // FIX: Wrap the entire handler in try/catch so errors surface as toasts
      const selectUser = async () => {
        searchInput.value = '';
        showChatListSection();

        try {
          const chatId = await getOrCreateChat(me.uid, user.uid);
          await openChat(chatId, user.uid, user);
        } catch (err) {
          console.error('openChat error:', err);
          toast('Failed to open chat. Please try again.', 'error');
        }
      };

      item.addEventListener('click', selectUser);
      item.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); selectUser(); }
      });
      frag.appendChild(item);
    }

    searchResults.innerHTML = '';
    searchResults.appendChild(frag);
  } catch (err) {
    console.error('Search error:', err);
    searchResults.innerHTML = `<div class="search-empty-state">Search failed. Try again.</div>`;
  }
}, 400);

searchInput.addEventListener('input',   e  => handleSearch(e.target.value));
searchInput.addEventListener('keydown', e  => {
  if (e.key === 'Escape') { searchInput.value = ''; showChatListSection(); searchInput.blur(); }
});

// ── Logout ─────────────────────────────────────────────────
logoutBtn.addEventListener('click', async () => {
  if (chatListUnsub)  chatListUnsub();
  if (msgUnsubscribe) msgUnsubscribe();
  try { await logout(); window.location.replace('/index.html'); }
  catch { toast('Sign out failed.', 'error'); }
});

// ── Mobile nav ─────────────────────────────────────────────
function showChatArea() { sidebar.classList.add('slide-out'); chatArea.classList.add('slide-in'); }
function showSidebarPanel() { sidebar.classList.remove('slide-out'); chatArea.classList.remove('slide-in'); }

backBtn.addEventListener('click', showSidebarPanel);

// ── Keep lastSeen fresh ────────────────────────────────────
setInterval(() => touchLastSeen(me.uid), 60_000);
</script>
</body>
</html>
